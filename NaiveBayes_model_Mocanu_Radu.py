# -*- coding: utf-8 -*-
"""BrainScanNaiveBayes.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YG2dELRJ7JZd5Y6DrnaSRF4_ns5fLTOQ
"""

from google.colab import drive
drive.mount('/content/gdrive')

!unzip  gdrive/My\ Drive/archive.zip

import matplotlib.pyplot as plt
from sklearn.naive_bayes import MultinomialNB
import numpy as np
from PIL import Image
from sklearn.metrics import precision_recall_curve
import matplotlib.pyplot as plt
from scipy.sparse import csr_matrix
import seaborn as sns
import pandas as pd
from sklearn import metrics

# adauga zerouri imaginii astfel incat sa se potriveasca cu formatul provided
def add_zeros(image_number):
    zeros_to_add = 6 - len(image_number)
    zeros = zeros_to_add * "0"
    return zeros + image_number

# citeste imaginile din fisierul dezarhivat
def get_images(start, number_of_images, base_path, number_of_images_to_process_at_a_time):
    processed_images = []
    total_images = []
    for i in range(start, start + number_of_images):
        image_name = add_zeros(str(i + 1))
        # convertesc imaginea din rgb in alb negru 
        img = Image.open(base_path + image_name + '.png').convert('L')
        # redimensionez imaginea 2D
        img_arr = np.array(img).reshape(-1) 
        processed_images.append(img_arr)
        if i % number_of_images_to_process_at_a_time == 0:
          print(i)
           #intorc doar un numar prestabilit de imagini la un moment dat pentru a nu da exceed memoria RAM
          total_images = total_images + processed_images
          # golesc lista 
          processed_images = []
    # verific daca am ajuns la finalul imaginilor de citit
    if len(processed_images):
      return np.array(total_images + processed_images)
    return np.array(total_images)

# citeste labelurile din fisier
def get_labels(number_of_rows, path):
  train_labels = []
  fisier = open(path ,'r')
  fisier.readline()
  for i in range (number_of_rows):
    img_number, label = [int (i) for i in fisier.readline().split(",")]
    train_labels.append(label)
  fisier.close()
  return train_labels

  
# citesc labelurile 
train_labels = get_labels(15000, '/content/train_labels.txt')
validation_labels = get_labels(2000, '/content/validation_labels.txt')

# citesc imaginile 
train_images  = get_images(0, 15000, '/content/data/data/', 500)

test_images = get_images(17000, 5149, '/content/data/data/', 500)

validation_images = get_images(15000, 2000, '/content/data/data/', 500)

# metoda ce imparte poza (matricea) in numarul de binuri specificat 
# intorc un csr_matrix, intrucat artmetice sunt mult mai rapide in cadrul acesteia 
def values_to_bins(matrice, bins):
    digitized = np.digitize(matrice, bins) - 1
    return csr_matrix(digitized)

# metoda ce antreneaza modelul Multinomial in funtie de parametrii specificati 
def MultinomialNB_method(mode, num_bins, no_to_proecess_at_a_time=500):
    # pixelii pozelor au valorile cuprinse intre 0 si 255
    # stabilesc valorile ce vor fi mapate fiecarui bean, in functie de paraetrul num_bins 
    bins = np.linspace(start=0, stop=255, num=num_bins)
    # definesc modelul 
    naive_bayes_model = MultinomialNB()
    # stabilesc numatul de iteratii, in functie de numarul de imagini pe care vreau sa le procesez la un moment dat 
    iterations  = int(np.ceil(len(train_images) / no_to_proecess_at_a_time))
    for index in range(iterations):
       # gasesc indicele de start al procesarii curente 
        start_index = index * no_to_proecess_at_a_time
        # verific daca nu cumva am ajuns la finalul imaginilor de antenament 
        end_index = min((index + 1) * no_to_proecess_at_a_time, len(train_images))
        # impart imaginile de antrenament in binuri 
        train_images_as_bins = values_to_bins(train_images[start_index:end_index], bins)
        # gasesc labelurile respective 
        current_train_labels = train_labels[start:end]
        # antrenez modelul 
        naive_bayes_model.partial_fit(train_images_as_bins, current_train_labels, classes=[0,1]))
    # in functie de modul de apelare al functiei returnez outputul dorit 
    if mode == "validation_score":
      return naive_bayes_model.score(values_to_bins(validation_images, bins),validation_labels)
    elif mode == "validation_predict":
      return naive_bayes_model.predict(values_to_bins(validation_images, bins))
    else:
      return naive_bayes_model.predict(values_to_bins(test_images, bins))

# creeaza fisierul de predictii in format csv 
 def createCsvFile(csvFileName, predictions): 
  with open(csvFileName, "w") as f: 
    print("id,class", file =f)
    predict_index = -1
    for i in range (17001, 22150):
      predict_index += 1
      print("0" + str(int(i)) + "," + str(int(predictions[predict_index])), file=f)
  f.close()

# functia utilizata pentru compararea modelelor 
 # va returna un dictionar de forma {numar_binuri: acurateatea_pe_setul_de_validare
 
def check_best_accuracy(test_numbers):
  accuracy = {}
  for test_number in test_numbers:
    print(test_number)
    accuracy[test_number] =  MultinomialNB_method("validation_score", test_number)
  return accuracy

# intoarce valoarea recall-ului pe clasa specificata
def getRecallValue(conf_matrix, classNumber):
  if classNumber == 0:
    return conf_matrix[0][0]/ (conf_matrix[0][0] + conf_matrix[0][1])
  return conf_matrix[1][1]/ (conf_matrix[1][1] + conf_matrix[1][0])

# intoarce matricea de confuzie 
def getConfusionMatrix(validation_labels, classes_predictions):
  conf_matrix = confusion_matrix(validation_labels, classes_predictions)
  return conf_matrix

# intoarce valoarea acuratetei pe clasa specificata
def getAccuracyValue(conf_matrix):
  return (conf_matrix[0][0] + conf_matrix[1][1])/np.sum(conf_matrix)

# intoarce valoarea preciziei pe clasa specificata
def getPrecisionValue(conf_matrix, classNumber):
  if classNumber == 0:
    return conf_matrix[0][0]/ (conf_matrix[0][0] + conf_matrix[1][0])
  return conf_matrix[1][1]/ (conf_matrix[1][1] + conf_matrix[0][1])

accuracy_dictionary = check_best_accuracy([int(i) for i in range (2,11)])

# ploteaza acuratetea in functie de numarul de binuri 

plt.plot(list(accuracy_dictionary.keys()), list(accuracy_dictionary.values()))
plt.xlabel('Numărul de binuri')
plt.ylabel('Acuratețea')
plt.title('Acuratețea în funcție de numărul de bin-uri [2,10]')
plt.show()

conf_matrix = getConfusionMatrix(validation_labels,predictii)

# ploteaza precizia fiecarei clase
precisions = [getPrecisionValue(conf_matrix, c) for c in [0,1]]
plt.bar(["Clasa 0 ", "Clasa 1"], precisions)
plt.xlabel('Clase')
plt.ylabel('Precizie')
plt.title('Precizia in functie de clasa')
plt.show()

# ploteaza recall-ul fiecarei clase
recalls = [getRecallValue(conf_matrix, c) for c in [0,1]]
plt.bar(["Clasa 0 ", "Clasa 1"], recalls, color="red")
plt.xlabel('Clase')
plt.ylabel('Recall')
plt.title('Recall-ul in functie de clasa')
plt.show()

# ploteaza matricea de confuzie

sns.heatmap(conf_matrix, cmap="YlOrRd", annot=True, fmt='d')
plt.title('Matricea de confuzie')
plt.show()

print(getAccuracyValue(conf_matrix))

predictii = MultinomialNB_method("validation_predict", 4)

createCsvFile("prediction_output.csv",predictii)